<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Walrus.jl</title><meta name="title" content="Library · Walrus.jl"/><meta property="og:title" content="Library · Walrus.jl"/><meta property="twitter:title" content="Library · Walrus.jl"/><meta name="description" content="Documentation for Walrus.jl."/><meta property="og:description" content="Documentation for Walrus.jl."/><meta property="twitter:description" content="Documentation for Walrus.jl."/><meta property="og:url" content="http://walrus.jagosw.com/stable/appendix/library/"/><meta property="twitter:url" content="http://walrus.jagosw.com/stable/appendix/library/"/><link rel="canonical" href="http://walrus.jagosw.com/stable/appendix/library/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Walrus.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Walrus.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../references/">References</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Appendix</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Wall-stress-model"><span>Wall stress model</span></a></li><li><a class="tocitem" href="#Radiative-transfer-models"><span>Radiative transfer models</span></a></li><li><a class="tocitem" href="#Tidal-forcing-models"><span>Tidal forcing models</span></a></li><li><a class="tocitem" href="#Wind-stress-model"><span>Wind stress model</span></a></li><li><a class="tocitem" href="#Surface-heat-exchange-model"><span>Surface heat exchange model</span></a></li></ul></li><li><a class="tocitem" href="../function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jagoosw/Walrus.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jagoosw/Walrus.jl/blob/main/docs/src/appendix/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="library_api"><a class="docs-heading-anchor" href="#library_api">Library</a><a id="library_api-1"></a><a class="docs-heading-anchor-permalink" href="#library_api" title="Permalink"></a></h1><p>Documenting the user interface.</p><h2 id="Wall-stress-model"><a class="docs-heading-anchor" href="#Wall-stress-model">Wall stress model</a><a id="Wall-stress-model-1"></a><a class="docs-heading-anchor-permalink" href="#Wall-stress-model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.WallStressModel" href="#Walrus.WallStressModel"><code>Walrus.WallStressModel</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WallStressModel</p><p>A wall stress model for LES simulation with default parameters similar to that proposed in <a href="../../references/#SCHUMANN1975376">Schumann (1975)</a>, <a href="../../references/#HARTEL1996283">Hartel (1996)</a>, <a href="../../references/#Piomelli1989">Piomelli <em>et al.</em> (1989)</a>, and <a href="../../references/#taylor2007">Taylor and Sarkar (2007)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/wall_model.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.WallStressModel.WallStress-Union{Tuple{}, Tuple{FT}} where FT" href="#Walrus.WallStressModel.WallStress-Union{Tuple{}, Tuple{FT}} where FT"><code>Walrus.WallStressModel.WallStress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WallStress(; von_Karman_constant = 0.4,
             kinematic_viscosity = 1e-6,
             B = 5.2,
             precomputed_friction_velocities = false,
             precompute_speeds = [0:25/100000:25;],
             grid = nothing,
             arch = isnothing(grid) ? CPU() : architecture(grid))</code></pre><p>Returns a wall stress model for LES simulation with default parameters similar to that proposed in <a href="../../references/#SCHUMANN1975376">Schumann (1975)</a>, <a href="../../references/#HARTEL1996283">Hartel (1996)</a>, <a href="../../references/#Piomelli1989">Piomelli <em>et al.</em> (1989)</a>, and <a href="../../references/#taylor2007">Taylor and Sarkar (2007)</a>.</p><p>Friction velocities will be precomputed at <code>precompute_speeds</code> if  <code>precomputed_friction_velocities</code> is true and <code>grid</code> is provided.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>von_Karman_constant</code>: the von Karman wall stress constant</li><li><code>kinematic_viscosity</code>: kinematic viscosity of the water above the wall</li><li><code>B</code>: wall stress constant </li><li><code>precomputed_friction_velocities</code>: precompute friction velocities?</li><li><code>precompute_speeds</code>: bottom water speeds to precompute friction velocities for,  this should encompas the range of speeds possible in your simulation</li><li><code>grid</code>: the grid to precompute the friction velocities for</li><li><code>arch</code>: architecture to adapt precomputed friction velocities for</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus: WallStress

julia&gt; using Oceananigans

julia&gt; wall_stress = WallStress()
(::WallStress{Float64, Nothing}) (generic function with 1 method)
julia&gt; boundary_conditions = (u = FieldBoundaryConditions(bottom = FluxBoundaryCondition(wall_stress, discrete_form = true, parameters = Val(:x))),
                              v = FieldBoundaryConditions(bottom = FluxBoundaryCondition(wall_stress, discrete_form = true, parameters = Val(:y))))
(u = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: FluxBoundaryCondition: DiscreteBoundaryFunction (::WallStress{Float64, Nothing}) with parameters Val{:x}
├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing), v = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: FluxBoundaryCondition: DiscreteBoundaryFunction (::WallStress{Float64, Nothing}) with parameters Val{:y}
├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/wall_model.jl#L39-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.WallStressModel.WallStressBoundaryConditions-Union{Tuple{}, Tuple{FT}} where FT" href="#Walrus.WallStressModel.WallStressBoundaryConditions-Union{Tuple{}, Tuple{FT}} where FT"><code>Walrus.WallStressModel.WallStressBoundaryConditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WallStressBoundaryConditions(; von_Karman_constant = 0.4,
                               kinematic_viscosity = 1e-6,
                               B = 5.2,
                               precompute_speeds = [0:25/100000:25;],
                               grid = nothing)</code></pre><p>Convenience constructor to setup <code>WallStress</code> boundary conditions.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>von_Karman_constant</code>: the von Karman wall stress constant</li><li><code>kinematic_viscosity</code>: kinematic viscosity of the water above the wall</li><li><code>B</code>: wall stress constant </li><li><code>precomputed_friction_velocities</code>: precompute friction velocities?</li><li><code>precompute_speeds</code>: bottom water speeds to precompute friction velocities for,  this should encompas the range of speeds possible in your simulation</li><li><code>grid</code>: the grid to precompute the friction velocities for</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus: WallStressBoundaryConditions

julia&gt; using Oceananigans

julia&gt; stress_boundary_conditions = WallStressBoundaryConditions()
(u = FluxBoundaryCondition: DiscreteBoundaryFunction (::WallStress{Float64, Nothing}) with parameters Val{:x}, v = FluxBoundaryCondition: DiscreteBoundaryFunction (::WallStress{Float64, Nothing}) with parameters Val{:y})
julia&gt; boundary_conditions = (u = FieldBoundaryConditions(bottom = stress_boundary_conditions.u),
                              v = FieldBoundaryConditions(bottom = stress_boundary_conditions.v))
(u = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: FluxBoundaryCondition: DiscreteBoundaryFunction (::WallStress{Float64, Nothing}) with parameters Val{:x}
├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing), v = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: FluxBoundaryCondition: DiscreteBoundaryFunction (::WallStress{Float64, Nothing}) with parameters Val{:y}
├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/wall_model.jl#L162-L210">source</a></section></article><h2 id="Radiative-transfer-models"><a class="docs-heading-anchor" href="#Radiative-transfer-models">Radiative transfer models</a><a id="Radiative-transfer-models-1"></a><a class="docs-heading-anchor-permalink" href="#Radiative-transfer-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.RadiativeTransfer" href="#Walrus.RadiativeTransfer"><code>Walrus.RadiativeTransfer</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>RadiativeTransfer</p><p>Includes models for ratiative transfer through water which can induce body heating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/radiative_transfer/radiative_transfer.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.RadiativeTransfer.HomogeneousBodyHeating" href="#Walrus.RadiativeTransfer.HomogeneousBodyHeating"><code>Walrus.RadiativeTransfer.HomogeneousBodyHeating</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HomogeneousBodyHeating</code></pre><p>A model for single band light attenuation which heats the water in the form:</p><p class="math-container">\[I(x, y, z) = I_0(x, y) * \exp\left(-\alpha z\right),\]</p><p>where <span>$I$</span> is the radiation intensity and <span>$\alpha$</span> is the attenuation coefficient. This heats the water like <span>$\frac{\partial T(x, y, z)}{\partial t} = \frac{I(x, y, z)A}{c^p\rho}$</span> where <span>$A$</span> is the area of the cell, <span>$c^p$</span> is the specific heat capacity and <span>$\rho$</span> is the water density. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/radiative_transfer/homogeneous_body_heating.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.RadiativeTransfer.HomogeneousBodyHeating-Tuple{}" href="#Walrus.RadiativeTransfer.HomogeneousBodyHeating-Tuple{}"><code>Walrus.RadiativeTransfer.HomogeneousBodyHeating</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HomogeneousBodyHeating(; surface_flux,
                         water_attenuation_coefficient = 1.8,
                         water_heat_capacity = 3991.0, # J K⁻¹ kg⁻¹
                         water_density = 1026.0) # kg m⁻³</code></pre><p>Creates a model in which a <code>surface_flux</code> (W / m²) is attenuated by and heats the water. This interacts with Oceananigans as a body forcing.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>surface_flux</code> (required): a function returning the surface radiaiton flux in the form <code>surface_flux(x, y, t)</code> or single value</li><li><code>water_attenuation_coefficient</code>: the radiation attenuation coefficient of the water</li><li><code>water_heat_capacity</code>: the specific heat capacity of the water</li><li><code>water_density</code>: density of the water</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus: HomogeneousBodyHeating

julia&gt; using Oceananigans

julia&gt; grid = RectilinearGrid(size = (128, 128, 128), extent = (1000, 1000, 1000))
128×128×128 RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 3×3×3 halo
├── Periodic x ∈ [0.0, 1000.0)  regularly spaced with Δx=7.8125
├── Periodic y ∈ [0.0, 1000.0)  regularly spaced with Δy=7.8125
└── Bounded  z ∈ [-1000.0, 0.0] regularly spaced with Δz=7.8125
julia&gt; body_heating = HomogeneousBodyHeating(; surface_flux = (x, y, t) -&gt; 100)
(::HomogeneousBodyHeating{Float64, Walrus.ContinuousSurfaceFunction{var&quot;#1#2&quot;}}) (generic function with 1 method)

julia&gt; model = NonhydrostaticModel(; grid, forcing = (; T = Forcing(body_heating, discrete_form=true)), tracers = :T)
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
├── grid: 128×128×128 RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 3×3×3 halo
├── timestepper: RungeKutta3TimeStepper
├── advection scheme: Centered(order=2)
├── tracers: T
├── closure: Nothing
├── buoyancy: Nothing
└── coriolis: Nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/radiative_transfer/homogeneous_body_heating.jl#L27-L70">source</a></section></article><h2 id="Tidal-forcing-models"><a class="docs-heading-anchor" href="#Tidal-forcing-models">Tidal forcing models</a><a id="Tidal-forcing-models-1"></a><a class="docs-heading-anchor-permalink" href="#Tidal-forcing-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.TidalForcings" href="#Walrus.TidalForcings"><code>Walrus.TidalForcings</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>TidalForcing</p><p>Provides quick setup of tidal forcing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/tidal_forcings.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.TidalForcings.Tide" href="#Walrus.TidalForcings.Tide"><code>Walrus.TidalForcings.Tide</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tide(; x_amplitude, 
       y_amplitude, 
       period = 12.3782216453hours,
       nodal_time = 0., 
       x_lag = 0., 
       y_lag = 0.,
       coriolis = nothing)</code></pre><p>Sets up a model of tidal forcing with default parameters of an M2 tide.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>x_amplitude</code>: the tidal amplitude in the x direction</li><li><code>y_amplitude</code>: the tidal amplitude in the x direction</li><li><code>period</code>: the tidal period (defaults to that of an M2 tide)</li><li><code>nodal_time</code>: the time at which peak flow occurs</li><li><code>x_lag</code>: the phase lag for the tidal component in the x direction</li><li><code>y_lag</code>: the phase lag for the tidal component in the y direction</li><li><code>coriolis</code>: a model for the coriolis parameter </li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus: Tide

julia&gt; using Oceananigans

julia&gt; tide = Tide(x_amplitude = 0.1, y_amplitude = 0.)
(::Tide{Float64, Nothing}) (generic function with 2 methods)
julia&gt; forcing = (u = Forcing(tide, parameters = Val(:x), discrete_form = true),
                  v = Forcing(tide, parameters = Val(:y), discrete_form = true))
(u = DiscreteForcing{Val{:x}}
├── func: (::Tide{Float64, Nothing}) (generic function with 2 methods)
└── parameters: Val{:x}(), v = DiscreteForcing{Val{:y}}
├── func: (::Tide{Float64, Nothing}) (generic function with 2 methods)
└── parameters: Val{:y}())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/tidal_forcings.jl#L17-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.TidalForcings.TidalForcing-Tuple{}" href="#Walrus.TidalForcings.TidalForcing-Tuple{}"><code>Walrus.TidalForcings.TidalForcing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TidalForcing(; x_amplitude,
               y_amplitude,
               period = 12.3782216453hours,
               nodal_time = 0.,
               x_lag = 0.,
               y_lag = 0.,
               coriolis = nothing)</code></pre><p>A convenience constructor for <code>Tide</code> which returns the forcings pre wrapped.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>x_amplitude</code>: the tidal amplitude in the x direction</li><li><code>y_amplitude</code>: the tidal amplitude in the x direction</li><li><code>period</code>: the tidal period (defaults to that of an M2 tide)</li><li><code>nodal_time</code>: the time at which peak flow occurs</li><li><code>x_lag</code>: the phase lag for the tidal component in the x direction</li><li><code>y_lag</code>: the phase lag for the tidal component in the y direction</li><li><code>coriolis</code>: a model for the coriolis parameter </li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus: TidalForcing

julia&gt; tidal_forcing = TidalForcing(x_amplitude = 0.1, y_amplitude = 0.)
(u = DiscreteForcing{Val{:x}}
├── func: (::Tide{Float64, Nothing}) (generic function with 2 methods)
└── parameters: Val{:x}(), v = DiscreteForcing{Val{:y}}
├── func: (::Tide{Float64, Nothing}) (generic function with 2 methods)
└── parameters: Val{:y}())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/tidal_forcings.jl#L95-L130">source</a></section></article><h2 id="Wind-stress-model"><a class="docs-heading-anchor" href="#Wind-stress-model">Wind stress model</a><a id="Wind-stress-model-1"></a><a class="docs-heading-anchor-permalink" href="#Wind-stress-model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.WindStressModel.LogarithmicNeutralWind-Union{Tuple{}, Tuple{FT}} where FT" href="#Walrus.WindStressModel.LogarithmicNeutralWind-Union{Tuple{}, Tuple{FT}} where FT"><code>Walrus.WindStressModel.LogarithmicNeutralWind</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LogarithmicNeutralWind(; monin_obukhov_stability_length = 0.4
                         charnock_coefficient = 0.014
                         air_kinematic_viscosity = 1.488e-5
                         gravity_wave_coefficient = 0.11
                         gravity = g_Earth,

                         precompute_drag_coefficients = false,
                         precompute_wind_speeds = [0:25/100000:25;],
                         arch = CPU())</code></pre><p>Returns a <code>LogarithmicNeutralWind</code> parameterisation for the surface drag coefficient</p><p><span>$C_d$</span> is parameterised as,</p><p class="math-container">\[C_d = \left(\frac{\kappa}{\log{\frac{10}{z_0}}}\right)^2,\]</p><p>where <span>$\kappa$</span> is the Monin‐Obukhov stability length and <span>$z_0$</span> is the velocity  roughness length. This is the roughness length scale which logarithmically brings  the relative velocity to zero at the surface, i.e.</p><p class="math-container">\[U=\frac{u\star}{\kappa}\log\frac{z}{z_0},\]</p><p>where <span>$u\star$</span> is the friction velocity. Additionally <span>$z_0$</span> is given as,</p><p class="math-container">\[z_0=b\frac{\nu}{u\star} + \frac{a_c}{g}u\star^2,\]</p><p>where <span>$\nu$</span> is the kinematic viscosity of air and g is the acceleration of gravity.</p><p>This model itterativly solves these equations to find <span>$z_0$</span>. Alternativly, if the flag  <code>precomputed_roughness_length</code> is set to they are pre computed at <code>precompute_wind_speeds</code>  between which <span>$z_0$</span> is then interpolated during run time. Precomputed velocities are  converted to appropriate types for <code>arch</code> (i.e. <code>CPU()</code> or <code>GPU()</code>)</p><p>This parameterisaion is described in <a href="../../references/#smith1988">Smith (1988)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/wind_stress.jl#L241-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.WindStressModel.WindStress-Tuple{}" href="#Walrus.WindStressModel.WindStress-Tuple{}"><code>Walrus.WindStressModel.WindStress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindStress(; reference_wind_speed, 
             reference_wind_direction,
             drag_coefficient = LogarithmicNeutralWind(), 
             air_density = 1.225, 
             water_density = 1026.)</code></pre><p>Returns a wind stress model where the stress is given by,</p><p class="math-container">\[\frac{\tau}{\rho_o} = \rho_aC_dSU_{x/y},\]</p><p>where <span>$\rho_o$</span> is the water density, <span>$\rho_a$</span> is the air density, <span>$C_d$</span> is the drag coefficient, <span>$U_{x/y}$</span> are the x and y components of  relative wind speed, and <span>$S=\sqrt{U_x^2+U_y^2}$</span>.</p><p><span>$C_d$</span> is calculated from a parameterisation, by default this is a &quot;log neutral&quot; wind parameterisation with velocity roughness length parameterisaion like <a href="../../references/#smith1988">Smith (1988)</a>.</p><p>In the default configuration this is the same as described in <a href="../../references/#fairall2011">Fairall <em>et al.</em> (2011)</a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>reference_wind_speed</code> (required): a function returning the (10m neutral) wind speed in the form <code>reference_wind_speed(x, y, t)</code> or single value</li><li><code>reference_wind_direction</code> (required): a function returning the (10m neutral) wind direction in the form <code>reference_wind_direction(x, y, t)</code> or single value</li><li><code>drag_coefficient</code>: the drag coefficient parameterisation</li><li><code>air_density</code>: air density in kg/m³ </li><li><code>water_density</code>: water density in kg/m³ </li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus: WindStress

julia&gt; using Oceananigans

julia&gt; reference_wind_speed = 0.1
0.1

julia&gt; reference_wind_direction = 0.
0.0

julia&gt; wind_stress = WindStress(; reference_wind_speed, reference_wind_direction)
(::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) (generic function with 2 methods)

julia&gt; boundary_conditions = (u = FieldBoundaryConditions(top = FluxBoundaryCondition(wind_stress, parameters = Val(:x))),
                              v = FieldBoundaryConditions(top = FluxBoundaryCondition(wind_stress, parameters = Val(:y))))
(u = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── top: FluxBoundaryCondition: ContinuousBoundaryFunction (::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) at (Nothing, Nothing, Nothing)
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing), v = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── top: FluxBoundaryCondition: ContinuousBoundaryFunction (::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) at (Nothing, Nothing, Nothing)
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/wind_stress.jl#L33-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.WindStressModel.WindStressBoundaryConditions-Tuple{}" href="#Walrus.WindStressModel.WindStressBoundaryConditions-Tuple{}"><code>Walrus.WindStressModel.WindStressBoundaryConditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WindStressBoundaryConditions(; reference_wind_speed, 
                               reference_wind_direction,
                               drag_coefficient = LogarithmicNeutralWind(), 
                               air_density = 1.225, 
                               water_density = 1026.)</code></pre><p>Convenience constructor to setup <code>WindStress</code> boundary conditions.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>reference_wind_speed</code> (required): a function returning the (10m neutral) wind speed in the form <code>reference_wind_speed(x, y, t)</code> or single value</li><li><code>reference_wind_direction</code> (required): a function returning the (10m neutral) wind direction in the form <code>reference_wind_direction(x, y, t)</code> or single value</li><li><code>drag_coefficient</code>: the drag coefficient parameterisation</li><li><code>air_density</code>: air density in kg/m³ </li><li><code>water_density</code>: water density in kg/m³ </li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus: WindStressBoundaryConditions

julia&gt; using Oceananigans

julia&gt; wind_stress_boundary_conditions = WindStressBoundaryConditions(; reference_wind_speed = 0.1, reference_wind_direction = 90.)
(u = FluxBoundaryCondition: DiscreteBoundaryFunction (::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) with parameters Val{:x}, v = FluxBoundaryCondition: DiscreteBoundaryFunction (::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) with parameters Val{:y})

julia&gt; boundary_conditions = (u = FieldBoundaryConditions(top = wind_stress_boundary_conditions.u),
                              v = FieldBoundaryConditions(top = wind_stress_boundary_conditions.v))
(u = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── top: FluxBoundaryCondition: DiscreteBoundaryFunction (::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) with parameters Val{:x}
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing), v = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── top: FluxBoundaryCondition: DiscreteBoundaryFunction (::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) with parameters Val{:y}
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/wind_stress.jl#L112-L161">source</a></section></article><h2 id="Surface-heat-exchange-model"><a class="docs-heading-anchor" href="#Surface-heat-exchange-model">Surface heat exchange model</a><a id="Surface-heat-exchange-model-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-heat-exchange-model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.SurfaceHeatingModel.SurfaceHeatExchange-Tuple{}" href="#Walrus.SurfaceHeatingModel.SurfaceHeatExchange-Tuple{}"><code>Walrus.SurfaceHeatingModel.SurfaceHeatExchange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SurfaceHeatExchange(; wind_stress,
                      air_temperature = 18, # °C
                      latent_heat_vaporisation = EmpiricalLatentHeatVaporisation(),
                      vapour_pressure = AugustRocheMagnusVapourPressure(),
                      water_specific_heat_capacity = 3991., # J / K / kg
                      water_density = 1026., # kg / m³
                      air_specific_heat_capacity = 1003.5, # J / K / kg
                      air_density = 1.204, # kg
                      air_water_mixing_ratio = 0.001, # kg / kg
                      stephan_boltzman_constant = 5.670374419e-8, # W / K⁴
                      ocean_emissivity = 0.97, #
                      downwelling_longwave = (T, args...)-&gt;60) # W</code></pre><p>Specifies surface heat exhange in the form:</p><p class="math-container">\[Q = Qᵢᵣ + Qₛ + Qₗ,\]</p><p>where <span>$Qᵢᵣ$</span> is the heat flux due to long wave (infra red) radiation, <span>$Qₛ$</span> is the sensible heat flux, and <span>$Qₗ$</span> is the latent heat flux. Notably the short wave radiation flux is neglegted here as it is assumed to penatrate far enough into the  water that it is treated separately by <code>HomogeneousBodyHeating</code> (we therefore are also assuming that the short wave penitration is suitably short that it is neglected).</p><p>The short wave term is given by the Stephan-Boltzman equation so:</p><p class="math-container">\[Qᵢᵣ = σ(T⁴ - Tₐ⁴),\]</p><p>where <span>$σ$</span> is the Stephan-Boltzman constant, <span>$T$</span> is the ocean temperature, and <span>$Tₐ$</span> is the 2m air temperature. </p><p>The sensible and latent heat flux&#39;s are given by the bluk parameterisations described in  <a href="../../references/#fairall2011">Fairall <em>et al.</em> (2011)</a> and are given by:</p><p class="math-container">\[Qₛ = ρₐcₚₐCₕS(T - Tₐ),\]</p><p>and <span>$Qₗ = ρₐLₑCₕS(q(T) - qₐ)$</span>,  where <span>$ρₐ$</span> is the density of the air, <span>$cₚₐ$</span> is the specific heat capacity of air,  <span>$Cₕ$</span> is the heat transfer coefficient, <span>$S$</span> is the wind speed, <span>$Lₑ$</span> is the latent heat of vaporizaion parameterised by <code>latent_heat_vaporisation</code>, <span>$q(T)$</span> is the  saturation vapour pressure of water and is parameterised by <code>vapour_pressure</code>.</p><p>The heat transfer coefficients are given by the same parameterisation as the <code>WindStress</code>. For example for the <code>LogarithmicNeutralWind</code> the transfer coefficient is given as: <span>$C_h = \frac{\kappa}{\log{\frac{2}{z_0}}}\frac{\kappa}{\log{\frac{2}{z_{ot}}}}$</span>, where <span>$z_{ot}$</span> is the sclar roughness parameter given by: <span>$z_{ot} = \min\left(1.15\cdot10^{-4}, 5.5\cdot10^{-5}R_r^{-0.6}\right)$</span>, where <span>$R_r$</span> is the roughness reynolds number given as <span>$R_r = \frac{u\star z_0}{\nu}$</span> where <span>$\nu$</span> is the kinematic viscosity of air.</p><p>The heat flux is then given by:</p><p class="math-container">\[F = \frac{Q}{\rho_oc_{po}},\]</p><p>where <span>$\rho_o$</span> and <span>$c_{po}$</span> are the density and specific heat capacity of water.</p><p>(Note: we will retain the Oceananigans convention that negative heat flux   at a top boundary increases temeprature).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>wind_stress</code>: wind stress model</li><li><code>air_temperature</code>: the air temperature in °C as a function with signature <code>(x, y, t)</code> or a constant</li><li><code>latent_heat_vaporisation</code>: latent heat of vaporisation in J / kg</li><li><code>vapour_pressure</code>: parameterisation for saturation vapour pressure in water</li><li><code>water_specific_heat_capacity</code>: the specific heat capacity of water in J / K / kg</li><li><code>water_density</code>: water density in kg / m³</li><li><code>air_specific_heat_capacit</code>: the specific heat capacity of air in J / K / kg</li><li><code>air_density</code>: air density in kg / m³</li><li><code>air_water_mixing_ratio</code>: water content of air in kg / kg</li><li><code>stephan_boltzman_constant</code>: the Stephan-Boltzman constant in W / K⁴</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus

julia&gt; using Oceananigans

julia&gt; wind_stress = WindStress(; reference_wind_speed = 0., reference_wind_direction = 90.)
(::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) (generic function with 2 methods)

julia&gt; surface_heat_exchange = SurfaceHeatExchange(; wind_stress)
(::SurfaceHeatExchange{WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}, Int64, Walrus.SurfaceHeatingModel.EmpiricalLatentHeatVaporisation{Float64}, Walrus.SurfaceHeatingModel.AugustRocheMagnusVapourPressure{Float64}, Float64, Walrus.SurfaceHeatingModel.EmpiricalDownwellingLongwave{Float64, Float64}}) (generic function with 1 method)

julia&gt; boundary_conditions = (; T = FieldBoundaryConditions(top = FluxBoundaryCondition(surface_heat_exchange, field_dependencies = (:T, :u, :v))))
(T = Oceananigans.FieldBoundaryConditions, with boundary conditions
├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
├── top: FluxBoundaryCondition: ContinuousBoundaryFunction (::SurfaceHeatExchange{WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}, Int64, Walrus.SurfaceHeatingModel.EmpiricalLatentHeatVaporisation{Float64}, Walrus.SurfaceHeatingModel.AugustRocheMagnusVapourPressure{Float64}, Float64, Walrus.SurfaceHeatingModel.EmpiricalDownwellingLongwave{Float64, Float64}}) at (Nothing, Nothing, Nothing)
└── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing),)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/surface_heating.jl#L46-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Walrus.SurfaceHeatingModel.SurfaceHeatExchangeBoundaryCondition-Tuple{}" href="#Walrus.SurfaceHeatingModel.SurfaceHeatExchangeBoundaryCondition-Tuple{}"><code>Walrus.SurfaceHeatingModel.SurfaceHeatExchangeBoundaryCondition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SurfaceHeatExchange(; wind_stress,
                      air_temperature = 18, # °C
                      latent_heat_vaporisation = EmpiricalLatentHeatVaporisation(),
                      vapour_pressure = AugustRocheMagnusVapourPressure(),
                      water_specific_heat_capacity = 3991., # J / K / kg
                      water_density = 1026., # kg / m³
                      air_specific_heat_capacity = 1003.5, # J / K / kg
                      air_density = 1.204, # kg
                      air_water_mixing_ratio = 0.001, # kg / kg
                      stephan_boltzman_constant = 5.670374419e-8, # W / K⁴
                      ocean_emissivity = 0.97) #</code></pre><p>A convenience constructor returning <code>SurfaceHeatExchange</code> as a boundary condition</p><p><strong>Keyword Arguments</strong></p><ul><li><code>wind_stress</code>: wind stress model</li><li><code>air_temperature</code>: the air temperature in °C as a function with signature <code>(x, y, t)</code> or a constant</li><li><code>latent_heat_vaporisation</code>: latent heat of vaporisation in J / kg</li><li><code>vapour_pressure</code>: parameterisation for saturation vapour pressure in water</li><li><code>water_specific_heat_capacity</code>: the specific heat capacity of water in J / K / kg</li><li><code>water_density</code>: water density in kg / m³</li><li><code>air_specific_heat_capacit</code>: the specific heat capacity of air in J / K / kg</li><li><code>air_density</code>: air density in kg / m³</li><li><code>air_water_mixing_ratio</code>: water content of air in kg / kg</li><li><code>stephan_boltzman_constant</code>: the Stephan-Boltzman constant in W / K⁴</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Walrus

julia&gt; wind_stress = WindStress(; reference_wind_speed = 0., reference_wind_direction = 90.)
(::WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}) (generic function with 2 methods)

julia&gt; surface_heat_exchange = SurfaceHeatExchangeBoundaryCondition(; wind_stress)
FluxBoundaryCondition: DiscreteBoundaryFunction with (::SurfaceHeatExchange{WindStress{Float64, Float64, LogarithmicNeutralWind{Float64, Nothing}, Float64}, Int64, Walrus.SurfaceHeatingModel.EmpiricalLatentHeatVaporisation{Float64}, Walrus.SurfaceHeatingModel.AugustRocheMagnusVapourPressure{Float64}, Float64, Walrus.SurfaceHeatingModel.EmpiricalDownwellingLongwave{Float64, Float64}})
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jagoosw/Walrus.jl/blob/c5bef6fc2cc8eaee653539332e29c4f5c9b5ff90/src/surface_heating.jl#L166-L207">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../references/">« References</a><a class="docs-footer-nextpage" href="../function_index/">Function index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 6 May 2025 12:14">Tuesday 6 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
